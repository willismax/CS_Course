<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CPUæ’ç­æ¼”ç®—æ³•æ•™å­¸ç¤ºç¯„</title>
    <style>
        body {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .algorithm-selector {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        .module-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e1e5e9;
        }
        
        .module-tab {
            padding: 12px 24px;
            border: none;
            background: transparent;
            color: #666;
            cursor: pointer;
            font-weight: 600;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }
        
        .module-tab:hover {
            color: #667eea;
            background: #f8f9fa;
        }
        
        .module-tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: #f8f9fa;
        }
        
        .module-content {
            margin-top: 20px;
        }
        
        .algorithm-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        .algorithm-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            background: #667eea;
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        
        .algorithm-btn:hover {
            background: #5a6fd8;
            transform: translateY(-2px);
        }
        
        .algorithm-btn.active {
            background: #764ba2;
            box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
        }
        
        .process-input {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        .input-row {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .input-group label {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }
        
        .input-group input {
            padding: 8px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            width: 80px;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .control-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: #28a745;
            color: white;
        }
        
        .btn-primary:hover {
            background: #218838;
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #545b62;
        }
        
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c82333;
        }
        
        .simulation-area {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        .process-list {
            margin-bottom: 20px;
        }
        
        .process-item {
            display: flex;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .gantt-chart {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .gantt-timeline {
            display: flex;
            margin-bottom: 10px;
            min-height: 40px;
            border: 2px solid #dee2e6;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .gantt-block {
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
            border-right: 1px solid #fff;
            transition: all 0.3s ease;
        }
        
        .gantt-block:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }
        
        .time-labels {
            display: flex;
            margin-top: 5px;
        }
        
        .time-label {
            font-size: 12px;
            text-align: center;
            color: #666;
        }
        
        .results {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .metric-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .metric-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        .algorithm-info {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .execution-demo {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            min-height: 200px;
            border: 2px solid #dee2e6;
        }
        
        .execution-log {
            background: #2d3748;
            color: #e2e8f0;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .demo-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .task-block {
            display: inline-block;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            font-size: 12px;
            animation: taskPulse 0.5s ease-in-out;
        }
        
        .task-running {
            animation: taskRunning 1s infinite alternate;
        }
        
        .task-waiting {
            opacity: 0.6;
            animation: taskWaiting 2s infinite;
        }
        
        .task-completed {
            opacity: 0.8;
            text-decoration: line-through;
        }
        
        .cpu-core {
            display: inline-block;
            width: 80px;
            height: 60px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 10px;
            margin: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
            position: relative;
        }
        
        .cpu-core.active {
            animation: cpuActive 1s infinite alternate;
        }
        
        @keyframes taskPulse {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes taskRunning {
            0% { box-shadow: 0 0 5px rgba(255, 255, 255, 0.5); }
            100% { box-shadow: 0 0 15px rgba(255, 255, 255, 0.8); }
        }
        
        @keyframes taskWaiting {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 0.3; }
        }
        
        @keyframes cpuActive {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); box-shadow: 0 0 10px rgba(255, 255, 255, 0.5); }
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            .input-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .algorithm-buttons {
                flex-direction: column;
            }
            
            .algorithm-btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ–¥ï¸ CPUæ’ç­æ¼”ç®—æ³•æ•™å­¸</h1>
            <p>äº’å‹•å¼å­¸ç¿’å¹³å° - è¦–è¦ºåŒ–ç†è§£å„ç¨®CPUæ’ç¨‹æ¼”ç®—æ³•</p>
        </div>
        
        <div class="algorithm-selector">
            <h3>é¸æ“‡å­¸ç¿’æ¨¡çµ„</h3>
            <div class="module-tabs">
                <button class="module-tab active" data-module="scheduling">æ’ç¨‹æ¼”ç®—æ³•</button>
                <button class="module-tab" data-module="sync-async">åŒæ­¥èˆ‡ç•°æ­¥</button>
                <button class="module-tab" data-module="multitasking">å¤šå·¥è™•ç†</button>
            </div>
            
            <div id="scheduling-module" class="module-content">
                <div class="algorithm-buttons">
                    <button class="algorithm-btn active" data-algorithm="fcfs">å…ˆåˆ°å…ˆæœå‹™ (FCFS)</button>
                    <button class="algorithm-btn" data-algorithm="sjf">æœ€çŸ­å·¥ä½œå„ªå…ˆ (SJF)</button>
                    <button class="algorithm-btn" data-algorithm="rr">è¼ªè½‰æ³• (Round Robin)</button>
                    <button class="algorithm-btn" data-algorithm="priority">å„ªå…ˆæ¬Šæ’ç¨‹</button>
                </div>
            </div>
            
            <div id="sync-async-module" class="module-content hidden">
                <div class="algorithm-buttons">
                    <button class="algorithm-btn active" data-algorithm="sync">åŒæ­¥åŸ·è¡Œ</button>
                    <button class="algorithm-btn" data-algorithm="async">ç•°æ­¥åŸ·è¡Œ</button>
                    <button class="algorithm-btn" data-algorithm="callback">å›èª¿å‡½æ•¸</button>
                    <button class="algorithm-btn" data-algorithm="promise">Promiseæ¨¡å¼</button>
                </div>
            </div>
            
            <div id="multitasking-module" class="module-content hidden">
                <div class="algorithm-buttons">
                    <button class="algorithm-btn active" data-algorithm="cooperative">å”ä½œå¼å¤šå·¥</button>
                    <button class="algorithm-btn" data-algorithm="preemptive">æ¶å å¼å¤šå·¥</button>
                    <button class="algorithm-btn" data-algorithm="threading">å¤šåŸ·è¡Œç·’</button>
                    <button class="algorithm-btn" data-algorithm="parallel">å¹³è¡Œè™•ç†</button>
                </div>
            </div>
            
            <div class="algorithm-info" id="algorithm-info">
                <h4>å…ˆåˆ°å…ˆæœå‹™ (First Come First Served)</h4>
                <p>æœ€ç°¡å–®çš„æ’ç¨‹æ¼”ç®—æ³•ï¼ŒæŒ‰ç…§è¡Œç¨‹åˆ°é”çš„é †åºåŸ·è¡Œã€‚å„ªé»æ˜¯å…¬å¹³ä¸”å¯¦ä½œç°¡å–®ï¼Œç¼ºé»æ˜¯å¯èƒ½é€ æˆè­·èˆªæ•ˆæ‡‰(Convoy Effect)ã€‚</p>
            </div>
        </div>
        
        <div class="process-input">
            <h3>æ–°å¢è¡Œç¨‹</h3>
            <div class="input-row">
                <div class="input-group">
                    <label>è¡Œç¨‹åç¨±</label>
                    <input type="text" id="processName" placeholder="P1" value="P1">
                </div>
                <div class="input-group">
                    <label>åˆ°é”æ™‚é–“</label>
                    <input type="number" id="arrivalTime" placeholder="0" value="0" min="0">
                </div>
                <div class="input-group">
                    <label>åŸ·è¡Œæ™‚é–“</label>
                    <input type="number" id="burstTime" placeholder="5" value="5" min="1">
                </div>
                <div class="input-group" id="priorityGroup" style="display: none;">
                    <label>å„ªå…ˆæ¬Š</label>
                    <input type="number" id="priority" placeholder="1" value="1" min="1">
                </div>
                <div class="input-group" id="quantumGroup" style="display: none;">
                    <label>æ™‚é–“é‡å­</label>
                    <input type="number" id="quantum" placeholder="2" value="2" min="1">
                </div>
            </div>
            
            <div class="control-buttons">
                <button class="btn btn-primary" onclick="addProcess()">æ–°å¢è¡Œç¨‹</button>
                <button class="btn btn-secondary" onclick="loadSampleData()">è¼‰å…¥ç¯„ä¾‹è³‡æ–™</button>
                <button class="btn btn-danger" onclick="clearProcesses()">æ¸…é™¤å…¨éƒ¨</button>
                <button class="btn btn-primary" onclick="runSimulation()">é–‹å§‹æ¨¡æ“¬</button>
            </div>
        </div>
        
        <div class="simulation-area">
            <div id="scheduling-simulation">
                <h3>è¡Œç¨‹åˆ—è¡¨</h3>
                <div class="process-list" id="processList">
                    <p style="color: #666; text-align: center;">å°šæœªæ–°å¢ä»»ä½•è¡Œç¨‹</p>
                </div>
                
                <div id="ganttChart" class="gantt-chart hidden">
                    <h4>ç”˜ç‰¹åœ– (Gantt Chart)</h4>
                    <div class="gantt-timeline" id="ganttTimeline"></div>
                    <div class="time-labels" id="timeLabels"></div>
                </div>
            </div>
            
            <div id="sync-async-simulation" class="hidden">
                <h3>åŒæ­¥èˆ‡ç•°æ­¥åŸ·è¡Œç¤ºç¯„</h3>
                <div class="demo-controls">
                    <button class="btn btn-primary" onclick="runSyncAsyncDemo()">é–‹å§‹ç¤ºç¯„</button>
                    <button class="btn btn-secondary" onclick="resetDemo()">é‡ç½®</button>
                </div>
                <div id="execution-timeline" class="execution-demo"></div>
                <div id="execution-log" class="execution-log"></div>
            </div>
            
            <div id="multitasking-simulation" class="hidden">
                <h3>å¤šå·¥è™•ç†ç¤ºç¯„</h3>
                <div class="demo-controls">
                    <button class="btn btn-primary" onclick="runMultitaskingDemo()">é–‹å§‹ç¤ºç¯„</button>
                    <button class="btn btn-secondary" onclick="resetDemo()">é‡ç½®</button>
                    <div class="input-group" style="display: inline-block; margin-left: 15px;">
                        <label>CPUæ ¸å¿ƒæ•¸</label>
                        <input type="number" id="cpuCores" value="4" min="1" max="8" style="width: 60px;">
                    </div>
                </div>
                <div id="multitask-timeline" class="execution-demo"></div>
                <div id="multitask-log" class="execution-log"></div>
            </div>
        </div>
        
        <div class="results" id="results" style="display: none;">
            <h3>åŸ·è¡Œçµæœèˆ‡æ•ˆèƒ½æŒ‡æ¨™</h3>
            <div id="processResults"></div>
            <div class="metrics" id="metrics"></div>
        </div>
    </div>

    <script>
        let processes = [];
        let currentAlgorithm = 'fcfs';
        let currentModule = 'scheduling';
        let processCounter = 1;
        
        const algorithmInfo = {
            // æ’ç¨‹æ¼”ç®—æ³•
            fcfs: {
                title: 'å…ˆåˆ°å…ˆæœå‹™ (First Come First Served)',
                description: 'æœ€ç°¡å–®çš„æ’ç¨‹æ¼”ç®—æ³•ï¼ŒæŒ‰ç…§è¡Œç¨‹åˆ°é”çš„é †åºåŸ·è¡Œã€‚å„ªé»æ˜¯å…¬å¹³ä¸”å¯¦ä½œç°¡å–®ï¼Œç¼ºé»æ˜¯å¯èƒ½é€ æˆè­·èˆªæ•ˆæ‡‰(Convoy Effect)ã€‚'
            },
            sjf: {
                title: 'æœ€çŸ­å·¥ä½œå„ªå…ˆ (Shortest Job First)',
                description: 'é¸æ“‡åŸ·è¡Œæ™‚é–“æœ€çŸ­çš„è¡Œç¨‹å„ªå…ˆåŸ·è¡Œã€‚èƒ½æœ€å°åŒ–å¹³å‡ç­‰å¾…æ™‚é–“ï¼Œä½†å¯èƒ½é€ æˆé•·è¡Œç¨‹é£¢é¤“å•é¡Œã€‚'
            },
            rr: {
                title: 'è¼ªè½‰æ³• (Round Robin)',
                description: 'æ¯å€‹è¡Œç¨‹åˆ†é…å›ºå®šçš„æ™‚é–“é‡å­ï¼Œæ™‚é–“åˆ°å°±åˆ‡æ›åˆ°ä¸‹ä¸€å€‹è¡Œç¨‹ã€‚é©åˆäº’å‹•å¼ç³»çµ±ï¼Œèƒ½æä¾›è‰¯å¥½çš„å›æ‡‰æ™‚é–“ã€‚'
            },
            priority: {
                title: 'å„ªå…ˆæ¬Šæ’ç¨‹ (Priority Scheduling)',
                description: 'æ ¹æ“šè¡Œç¨‹çš„å„ªå…ˆæ¬Šæ±ºå®šåŸ·è¡Œé †åºï¼Œæ•¸å­—è¶Šå°å„ªå…ˆæ¬Šè¶Šé«˜ã€‚å¯èƒ½é€ æˆä½å„ªå…ˆæ¬Šè¡Œç¨‹é£¢é¤“å•é¡Œã€‚'
            },
            // åŒæ­¥èˆ‡ç•°æ­¥
            sync: {
                title: 'åŒæ­¥åŸ·è¡Œ (Synchronous Execution)',
                description: 'ç¨‹å¼æŒ‰é †åºåŸ·è¡Œï¼Œæ¯å€‹ä»»å‹™å¿…é ˆç­‰å¾…å‰ä¸€å€‹ä»»å‹™å®Œæˆæ‰èƒ½é–‹å§‹ã€‚åŸ·è¡Œé †åºå¯é æ¸¬ï¼Œä½†å¯èƒ½é€ æˆé˜»å¡ã€‚'
            },
            async: {
                title: 'ç•°æ­¥åŸ·è¡Œ (Asynchronous Execution)',
                description: 'ä»»å‹™å¯ä»¥ä¸¦è¡ŒåŸ·è¡Œï¼Œä¸éœ€è¦ç­‰å¾…å…¶ä»–ä»»å‹™å®Œæˆã€‚æé«˜æ•ˆç‡ä½†å¢åŠ è¤‡é›œæ€§ï¼Œéœ€è¦è™•ç†ç«¶çˆ­æ¢ä»¶ã€‚'
            },
            callback: {
                title: 'å›èª¿å‡½æ•¸ (Callback Functions)',
                description: 'å°‡å‡½æ•¸ä½œç‚ºåƒæ•¸å‚³éï¼Œåœ¨ç‰¹å®šäº‹ä»¶ç™¼ç”Ÿæ™‚è¢«èª¿ç”¨ã€‚æ˜¯å¯¦ç¾ç•°æ­¥ç¨‹å¼è¨­è¨ˆçš„åŸºæœ¬æ–¹å¼ã€‚'
            },
            promise: {
                title: 'Promiseæ¨¡å¼',
                description: 'ç”¨æ–¼è™•ç†ç•°æ­¥æ“ä½œçš„ç‰©ä»¶ï¼Œä»£è¡¨ä¸€å€‹å¯èƒ½åœ¨æœªä¾†å®Œæˆçš„æ“ä½œçµæœã€‚é¿å…å›èª¿åœ°ç„ï¼Œæä¾›æ›´æ¸…æ™°çš„éŒ¯èª¤è™•ç†ã€‚'
            },
            // å¤šå·¥è™•ç†
            cooperative: {
                title: 'å”ä½œå¼å¤šå·¥ (Cooperative Multitasking)',
                description: 'ä»»å‹™ä¸»å‹•è®“å‡ºCPUæ§åˆ¶æ¬Šï¼Œä¾è³´ç¨‹å¼è‡ªèº«çš„åˆä½œã€‚ç°¡å–®ä½†å¯èƒ½å› ç‚ºä¸åˆä½œçš„ç¨‹å¼é€ æˆç³»çµ±åœé “ã€‚'
            },
            preemptive: {
                title: 'æ¶å å¼å¤šå·¥ (Preemptive Multitasking)',
                description: 'ä½œæ¥­ç³»çµ±å¼·åˆ¶åˆ‡æ›ä»»å‹™ï¼Œä¸ä¾è³´ç¨‹å¼åˆä½œã€‚æä¾›æ›´å¥½çš„ç³»çµ±ç©©å®šæ€§å’Œå›æ‡‰æ€§ã€‚'
            },
            threading: {
                title: 'å¤šåŸ·è¡Œç·’ (Multi-threading)',
                description: 'åœ¨åŒä¸€å€‹ç¨‹åºä¸­å‰µå»ºå¤šå€‹åŸ·è¡Œç·’ï¼Œå…±äº«è¨˜æ†¶é«”ç©ºé–“ã€‚é©åˆI/Oå¯†é›†å‹ä»»å‹™ï¼Œä½†éœ€è¦è™•ç†åŒæ­¥å•é¡Œã€‚'
            },
            parallel: {
                title: 'å¹³è¡Œè™•ç† (Parallel Processing)',
                description: 'åŒæ™‚åœ¨å¤šå€‹CPUæ ¸å¿ƒä¸ŠåŸ·è¡Œä»»å‹™ï¼ŒçœŸæ­£çš„ä¸¦è¡ŒåŸ·è¡Œã€‚é©åˆCPUå¯†é›†å‹ä»»å‹™ï¼Œèƒ½å……åˆ†åˆ©ç”¨å¤šæ ¸å¿ƒå„ªå‹¢ã€‚'
            }
        };
        
        const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F'];
        
        // æ¨¡çµ„åˆ‡æ›
        document.querySelectorAll('.module-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                document.querySelectorAll('.module-tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                currentModule = this.dataset.module;
                
                // éš±è—æ‰€æœ‰æ¨¡çµ„å…§å®¹
                document.querySelectorAll('.module-content').forEach(content => {
                    content.classList.add('hidden');
                });
                
                // é¡¯ç¤ºé¸ä¸­çš„æ¨¡çµ„
                document.getElementById(currentModule + '-module').classList.remove('hidden');
                
                // é‡ç½®ç‚ºè©²æ¨¡çµ„çš„ç¬¬ä¸€å€‹æ¼”ç®—æ³•
                const firstBtn = document.querySelector(`#${currentModule}-module .algorithm-btn`);
                if (firstBtn) {
                    document.querySelectorAll('.algorithm-btn').forEach(b => b.classList.remove('active'));
                    firstBtn.classList.add('active');
                    currentAlgorithm = firstBtn.dataset.algorithm;
                }
                
                updateAlgorithmInfo();
                updateInputFields();
                clearResults();
                updateProcessInputVisibility();
            });
        });
        
        // æ¼”ç®—æ³•é¸æ“‡
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('algorithm-btn')) {
                document.querySelectorAll('.algorithm-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                currentAlgorithm = e.target.dataset.algorithm;
                updateAlgorithmInfo();
                updateInputFields();
                clearResults();
            }
        });
        
        function updateAlgorithmInfo() {
            const info = algorithmInfo[currentAlgorithm];
            document.getElementById('algorithm-info').innerHTML = `
                <h4>${info.title}</h4>
                <p>${info.description}</p>
            `;
        }
        
        function updateInputFields() {
            const priorityGroup = document.getElementById('priorityGroup');
            const quantumGroup = document.getElementById('quantumGroup');
            
            priorityGroup.style.display = currentAlgorithm === 'priority' ? 'block' : 'none';
            quantumGroup.style.display = currentAlgorithm === 'rr' ? 'block' : 'none';
        }
        
        function updateProcessInputVisibility() {
            const processInput = document.querySelector('.process-input');
            const schedulingSimulation = document.getElementById('scheduling-simulation');
            const syncAsyncSimulation = document.getElementById('sync-async-simulation');
            const multitaskingSimulation = document.getElementById('multitasking-simulation');
            
            // éš±è—æ‰€æœ‰æ¨¡æ“¬å€åŸŸ
            schedulingSimulation.classList.add('hidden');
            syncAsyncSimulation.classList.add('hidden');
            multitaskingSimulation.classList.add('hidden');
            
            if (currentModule === 'scheduling') {
                processInput.style.display = 'block';
                schedulingSimulation.classList.remove('hidden');
            } else if (currentModule === 'sync-async') {
                processInput.style.display = 'none';
                syncAsyncSimulation.classList.remove('hidden');
            } else if (currentModule === 'multitasking') {
                processInput.style.display = 'none';
                multitaskingSimulation.classList.remove('hidden');
            }
        }
        
        function addProcess() {
            const name = document.getElementById('processName').value || `P${processCounter}`;
            const arrivalTime = parseInt(document.getElementById('arrivalTime').value) || 0;
            const burstTime = parseInt(document.getElementById('burstTime').value) || 1;
            const priority = parseInt(document.getElementById('priority').value) || 1;
            
            const process = {
                id: processes.length,
                name: name,
                arrivalTime: arrivalTime,
                burstTime: burstTime,
                priority: priority,
                remainingTime: burstTime,
                color: colors[processes.length % colors.length]
            };
            
            processes.push(process);
            processCounter++;
            
            // æ›´æ–°ä¸‹ä¸€å€‹è¡Œç¨‹åç¨±
            document.getElementById('processName').value = `P${processCounter}`;
            
            updateProcessList();
            clearResults();
        }
        
        function updateProcessList() {
            const listElement = document.getElementById('processList');
            
            if (processes.length === 0) {
                listElement.innerHTML = '<p style="color: #666; text-align: center;">å°šæœªæ–°å¢ä»»ä½•è¡Œç¨‹</p>';
                return;
            }
            
            listElement.innerHTML = processes.map(process => `
                <div class="process-item">
                    <div style="width: 20px; height: 20px; background: ${process.color}; border-radius: 50%; margin-right: 10px;"></div>
                    <strong>${process.name}</strong>
                    <span style="margin-left: 15px;">åˆ°é”: ${process.arrivalTime}</span>
                    <span style="margin-left: 15px;">åŸ·è¡Œ: ${process.burstTime}</span>
                    ${currentAlgorithm === 'priority' ? `<span style="margin-left: 15px;">å„ªå…ˆæ¬Š: ${process.priority}</span>` : ''}
                    <button onclick="removeProcess(${process.id})" style="margin-left: auto; background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">åˆªé™¤</button>
                </div>
            `).join('');
        }
        
        function removeProcess(id) {
            processes = processes.filter(p => p.id !== id);
            updateProcessList();
            clearResults();
        }
        
        function clearProcesses() {
            processes = [];
            processCounter = 1;
            document.getElementById('processName').value = 'P1';
            updateProcessList();
            clearResults();
        }
        
        function loadSampleData() {
            processes = [
                { id: 0, name: 'P1', arrivalTime: 0, burstTime: 8, priority: 3, remainingTime: 8, color: colors[0] },
                { id: 1, name: 'P2', arrivalTime: 1, burstTime: 4, priority: 1, remainingTime: 4, color: colors[1] },
                { id: 2, name: 'P3', arrivalTime: 2, burstTime: 9, priority: 4, remainingTime: 9, color: colors[2] },
                { id: 3, name: 'P4', arrivalTime: 3, burstTime: 5, priority: 2, remainingTime: 5, color: colors[3] }
            ];
            processCounter = 5;
            document.getElementById('processName').value = 'P5';
            updateProcessList();
            clearResults();
        }
        
        function clearResults() {
            document.getElementById('ganttChart').classList.add('hidden');
            document.getElementById('results').style.display = 'none';
        }
        
        function runSimulation() {
            if (processes.length === 0) {
                alert('è«‹å…ˆæ–°å¢è¡Œç¨‹ï¼');
                return;
            }
            
            let result;
            const quantum = parseInt(document.getElementById('quantum').value) || 2;
            
            switch (currentAlgorithm) {
                case 'fcfs':
                    result = simulateFCFS();
                    break;
                case 'sjf':
                    result = simulateSJF();
                    break;
                case 'rr':
                    result = simulateRR(quantum);
                    break;
                case 'priority':
                    result = simulatePriority();
                    break;
            }
            
            displayResults(result);
        }
        
        function simulateFCFS() {
            const sortedProcesses = [...processes].sort((a, b) => a.arrivalTime - b.arrivalTime);
            const timeline = [];
            let currentTime = 0;
            
            sortedProcesses.forEach(process => {
                if (currentTime < process.arrivalTime) {
                    currentTime = process.arrivalTime;
                }
                
                timeline.push({
                    process: process,
                    startTime: currentTime,
                    endTime: currentTime + process.burstTime
                });
                
                currentTime += process.burstTime;
            });
            
            return calculateMetrics(timeline);
        }
        
        function simulateSJF() {
            const timeline = [];
            let currentTime = 0;
            const remaining = [...processes];
            
            while (remaining.length > 0) {
                const available = remaining.filter(p => p.arrivalTime <= currentTime);
                
                if (available.length === 0) {
                    currentTime = Math.min(...remaining.map(p => p.arrivalTime));
                    continue;
                }
                
                const shortest = available.reduce((min, p) => p.burstTime < min.burstTime ? p : min);
                const index = remaining.indexOf(shortest);
                remaining.splice(index, 1);
                
                timeline.push({
                    process: shortest,
                    startTime: currentTime,
                    endTime: currentTime + shortest.burstTime
                });
                
                currentTime += shortest.burstTime;
            }
            
            return calculateMetrics(timeline);
        }
        
        function simulateRR(quantum) {
            const timeline = [];
            let currentTime = 0;
            const queue = [];
            const remaining = [...processes].map(p => ({...p, remainingTime: p.burstTime}));
            let processIndex = 0;
            
            while (remaining.some(p => p.remainingTime > 0) || queue.length > 0) {
                // æ–°å¢åˆ°é”çš„è¡Œç¨‹
                while (processIndex < remaining.length && remaining[processIndex].arrivalTime <= currentTime) {
                    queue.push(remaining[processIndex]);
                    processIndex++;
                }
                
                if (queue.length === 0) {
                    currentTime = remaining[processIndex].arrivalTime;
                    continue;
                }
                
                const current = queue.shift();
                const executeTime = Math.min(quantum, current.remainingTime);
                
                timeline.push({
                    process: current,
                    startTime: currentTime,
                    endTime: currentTime + executeTime
                });
                
                currentTime += executeTime;
                current.remainingTime -= executeTime;
                
                // æ–°å¢åœ¨åŸ·è¡ŒæœŸé–“åˆ°é”çš„è¡Œç¨‹
                while (processIndex < remaining.length && remaining[processIndex].arrivalTime <= currentTime) {
                    queue.push(remaining[processIndex]);
                    processIndex++;
                }
                
                if (current.remainingTime > 0) {
                    queue.push(current);
                }
            }
            
            return calculateMetrics(timeline);
        }
        
        function simulatePriority() {
            const timeline = [];
            let currentTime = 0;
            const remaining = [...processes];
            
            while (remaining.length > 0) {
                const available = remaining.filter(p => p.arrivalTime <= currentTime);
                
                if (available.length === 0) {
                    currentTime = Math.min(...remaining.map(p => p.arrivalTime));
                    continue;
                }
                
                const highest = available.reduce((min, p) => p.priority < min.priority ? p : min);
                const index = remaining.indexOf(highest);
                remaining.splice(index, 1);
                
                timeline.push({
                    process: highest,
                    startTime: currentTime,
                    endTime: currentTime + highest.burstTime
                });
                
                currentTime += highest.burstTime;
            }
            
            return calculateMetrics(timeline);
        }
        
        function calculateMetrics(timeline) {
            const processMetrics = {};
            
            processes.forEach(process => {
                const processBlocks = timeline.filter(block => block.process.id === process.id);
                const completionTime = Math.max(...processBlocks.map(block => block.endTime));
                const turnaroundTime = completionTime - process.arrivalTime;
                const waitingTime = turnaroundTime - process.burstTime;
                
                processMetrics[process.id] = {
                    process: process,
                    completionTime: completionTime,
                    turnaroundTime: turnaroundTime,
                    waitingTime: waitingTime
                };
            });
            
            const avgTurnaroundTime = Object.values(processMetrics).reduce((sum, p) => sum + p.turnaroundTime, 0) / processes.length;
            const avgWaitingTime = Object.values(processMetrics).reduce((sum, p) => sum + p.waitingTime, 0) / processes.length;
            const totalTime = Math.max(...timeline.map(block => block.endTime));
            const throughput = processes.length / totalTime;
            
            return {
                timeline: timeline,
                processMetrics: processMetrics,
                avgTurnaroundTime: avgTurnaroundTime.toFixed(2),
                avgWaitingTime: avgWaitingTime.toFixed(2),
                totalTime: totalTime,
                throughput: throughput.toFixed(3)
            };
        }
        
        function displayResults(result) {
            // é¡¯ç¤ºç”˜ç‰¹åœ–
            displayGanttChart(result.timeline);
            
            // é¡¯ç¤ºçµæœè¡¨æ ¼
            const resultsDiv = document.getElementById('results');
            const processResultsDiv = document.getElementById('processResults');
            
            let tableHTML = `
                <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px;">
                    <thead>
                        <tr style="background: #f8f9fa;">
                            <th style="padding: 10px; border: 1px solid #dee2e6;">è¡Œç¨‹</th>
                            <th style="padding: 10px; border: 1px solid #dee2e6;">åˆ°é”æ™‚é–“</th>
                            <th style="padding: 10px; border: 1px solid #dee2e6;">åŸ·è¡Œæ™‚é–“</th>
                            <th style="padding: 10px; border: 1px solid #dee2e6;">å®Œæˆæ™‚é–“</th>
                            <th style="padding: 10px; border: 1px solid #dee2e6;">å›è½‰æ™‚é–“</th>
                            <th style="padding: 10px; border: 1px solid #dee2e6;">ç­‰å¾…æ™‚é–“</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            Object.values(result.processMetrics).forEach(metric => {
                tableHTML += `
                    <tr>
                        <td style="padding: 10px; border: 1px solid #dee2e6; text-align: center;">
                            <div style="display: flex; align-items: center; justify-content: center;">
                                <div style="width: 15px; height: 15px; background: ${metric.process.color}; border-radius: 50%; margin-right: 8px;"></div>
                                ${metric.process.name}
                            </div>
                        </td>
                        <td style="padding: 10px; border: 1px solid #dee2e6; text-align: center;">${metric.process.arrivalTime}</td>
                        <td style="padding: 10px; border: 1px solid #dee2e6; text-align: center;">${metric.process.burstTime}</td>
                        <td style="padding: 10px; border: 1px solid #dee2e6; text-align: center;">${metric.completionTime}</td>
                        <td style="padding: 10px; border: 1px solid #dee2e6; text-align: center;">${metric.turnaroundTime}</td>
                        <td style="padding: 10px; border: 1px solid #dee2e6; text-align: center;">${metric.waitingTime}</td>
                    </tr>
                `;
            });
            
            tableHTML += '</tbody></table>';
            processResultsDiv.innerHTML = tableHTML;
            
            // é¡¯ç¤ºæ•ˆèƒ½æŒ‡æ¨™
            const metricsDiv = document.getElementById('metrics');
            metricsDiv.innerHTML = `
                <div class="metric-card">
                    <div class="metric-value">${result.avgTurnaroundTime}</div>
                    <div class="metric-label">å¹³å‡å›è½‰æ™‚é–“</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${result.avgWaitingTime}</div>
                    <div class="metric-label">å¹³å‡ç­‰å¾…æ™‚é–“</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${result.totalTime}</div>
                    <div class="metric-label">ç¸½åŸ·è¡Œæ™‚é–“</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${result.throughput}</div>
                    <div class="metric-label">ç”¢å‡ºç‡ (è¡Œç¨‹/æ™‚é–“)</div>
                </div>
            `;
            
            resultsDiv.style.display = 'block';
        }
        
        function displayGanttChart(timeline) {
            const ganttTimeline = document.getElementById('ganttTimeline');
            const timeLabels = document.getElementById('timeLabels');
            const totalTime = Math.max(...timeline.map(block => block.endTime));
            
            ganttTimeline.innerHTML = '';
            timeLabels.innerHTML = '';
            
            timeline.forEach(block => {
                const width = ((block.endTime - block.startTime) / totalTime) * 100;
                const ganttBlock = document.createElement('div');
                ganttBlock.className = 'gantt-block';
                ganttBlock.style.width = width + '%';
                ganttBlock.style.background = block.process.color;
                ganttBlock.textContent = block.process.name;
                ganttBlock.title = `${block.process.name}: ${block.startTime}-${block.endTime}`;
                ganttTimeline.appendChild(ganttBlock);
            });
            
            // æ™‚é–“æ¨™ç±¤
            for (let i = 0; i <= totalTime; i++) {
                const label = document.createElement('div');
                label.className = 'time-label';
                label.style.width = (100 / totalTime) + '%';
                label.textContent = i;
                timeLabels.appendChild(label);
            }
            
            document.getElementById('ganttChart').classList.remove('hidden');
        }
        
        // åŒæ­¥ç•°æ­¥ç¤ºç¯„
        function runSyncAsyncDemo() {
            const timeline = document.getElementById('execution-timeline');
            const log = document.getElementById('execution-log');
            
            timeline.innerHTML = '';
            log.innerHTML = '';
            
            if (currentAlgorithm === 'sync') {
                runSyncDemo(timeline, log);
            } else if (currentAlgorithm === 'async') {
                runAsyncDemo(timeline, log);
            } else if (currentAlgorithm === 'callback') {
                runCallbackDemo(timeline, log);
            } else if (currentAlgorithm === 'promise') {
                runPromiseDemo(timeline, log);
            }
        }
        
        function runSyncDemo(timeline, log) {
            const tasks = ['è®€å–æª”æ¡ˆ', 'è™•ç†è³‡æ–™', 'å¯«å…¥çµæœ', 'ç™¼é€é€šçŸ¥'];
            let currentTime = 0;
            
            log.innerHTML += `<div>[${formatTime(currentTime)}] é–‹å§‹åŒæ­¥åŸ·è¡Œ...</div>`;
            
            tasks.forEach((task, index) => {
                setTimeout(() => {
                    const taskElement = document.createElement('div');
                    taskElement.className = 'task-block task-running';
                    taskElement.style.background = colors[index];
                    taskElement.textContent = task;
                    timeline.appendChild(taskElement);
                    
                    log.innerHTML += `<div>[${formatTime(currentTime + (index + 1) * 1000)}] åŸ·è¡Œ: ${task}</div>`;
                    
                    setTimeout(() => {
                        taskElement.classList.remove('task-running');
                        taskElement.classList.add('task-completed');
                        log.innerHTML += `<div>[${formatTime(currentTime + (index + 1) * 1500)}] å®Œæˆ: ${task}</div>`;
                        
                        if (index === tasks.length - 1) {
                            log.innerHTML += `<div>[${formatTime(currentTime + tasks.length * 1500)}] æ‰€æœ‰ä»»å‹™å®Œæˆï¼ç¸½æ™‚é–“: ${tasks.length * 1.5}ç§’</div>`;
                        }
                    }, 500);
                }, index * 1000);
            });
        }
        
        function runAsyncDemo(timeline, log) {
            const tasks = ['è®€å–æª”æ¡ˆ', 'è™•ç†è³‡æ–™', 'å¯«å…¥çµæœ', 'ç™¼é€é€šçŸ¥'];
            let currentTime = 0;
            
            log.innerHTML += `<div>[${formatTime(currentTime)}] é–‹å§‹ç•°æ­¥åŸ·è¡Œ...</div>`;
            
            tasks.forEach((task, index) => {
                setTimeout(() => {
                    const taskElement = document.createElement('div');
                    taskElement.className = 'task-block task-running';
                    taskElement.style.background = colors[index];
                    taskElement.textContent = task;
                    timeline.appendChild(taskElement);
                    
                    log.innerHTML += `<div>[${formatTime(currentTime + 100)}] å•Ÿå‹•: ${task}</div>`;
                    
                    const duration = Math.random() * 1000 + 500;
                    setTimeout(() => {
                        taskElement.classList.remove('task-running');
                        taskElement.classList.add('task-completed');
                        log.innerHTML += `<div>[${formatTime(currentTime + duration)}] å®Œæˆ: ${task}</div>`;
                    }, duration);
                }, index * 100);
            });
            
            setTimeout(() => {
                log.innerHTML += `<div>[${formatTime(currentTime + 2000)}] æ‰€æœ‰ä»»å‹™å·²å•Ÿå‹•ï¼ç•°æ­¥åŸ·è¡Œä¸­...</div>`;
            }, 500);
        }
        
        function runCallbackDemo(timeline, log) {
            log.innerHTML += `<div>[0ms] é–‹å§‹å›èª¿å‡½æ•¸ç¤ºç¯„...</div>`;
            
            function task1(callback) {
                const taskElement = document.createElement('div');
                taskElement.className = 'task-block task-running';
                taskElement.style.background = colors[0];
                taskElement.textContent = 'ä»»å‹™1';
                timeline.appendChild(taskElement);
                
                setTimeout(() => {
                    taskElement.classList.remove('task-running');
                    taskElement.classList.add('task-completed');
                    log.innerHTML += `<div>[1000ms] ä»»å‹™1å®Œæˆï¼Œèª¿ç”¨å›èª¿å‡½æ•¸</div>`;
                    callback();
                }, 1000);
            }
            
            function task2(callback) {
                const taskElement = document.createElement('div');
                taskElement.className = 'task-block task-running';
                taskElement.style.background = colors[1];
                taskElement.textContent = 'ä»»å‹™2';
                timeline.appendChild(taskElement);
                
                setTimeout(() => {
                    taskElement.classList.remove('task-running');
                    taskElement.classList.add('task-completed');
                    log.innerHTML += `<div>[2000ms] ä»»å‹™2å®Œæˆï¼Œèª¿ç”¨å›èª¿å‡½æ•¸</div>`;
                    callback();
                }, 1000);
            }
            
            task1(() => {
                task2(() => {
                    log.innerHTML += `<div>[2000ms] æ‰€æœ‰å›èª¿å®Œæˆï¼</div>`;
                });
            });
        }
        
        function runPromiseDemo(timeline, log) {
            log.innerHTML += `<div>[0ms] é–‹å§‹Promiseç¤ºç¯„...</div>`;
            
            function createTask(name, index, duration) {
                return new Promise((resolve) => {
                    const taskElement = document.createElement('div');
                    taskElement.className = 'task-block task-running';
                    taskElement.style.background = colors[index];
                    taskElement.textContent = name;
                    timeline.appendChild(taskElement);
                    
                    setTimeout(() => {
                        taskElement.classList.remove('task-running');
                        taskElement.classList.add('task-completed');
                        log.innerHTML += `<div>[${duration}ms] ${name}å®Œæˆ</div>`;
                        resolve(name);
                    }, duration);
                });
            }
            
            createTask('Promiseä»»å‹™1', 0, 800)
                .then(() => createTask('Promiseä»»å‹™2', 1, 600))
                .then(() => createTask('Promiseä»»å‹™3', 2, 1000))
                .then(() => {
                    log.innerHTML += `<div>[2400ms] Promiseéˆå®Œæˆï¼</div>`;
                })
                .catch((error) => {
                    log.innerHTML += `<div>éŒ¯èª¤: ${error}</div>`;
                });
        }
        
        // å¤šå·¥è™•ç†ç¤ºç¯„
        function runMultitaskingDemo() {
            const timeline = document.getElementById('multitask-timeline');
            const log = document.getElementById('multitask-log');
            const cores = parseInt(document.getElementById('cpuCores').value) || 4;
            
            timeline.innerHTML = '';
            log.innerHTML = '';
            
            if (currentAlgorithm === 'cooperative') {
                runCooperativeDemo(timeline, log);
            } else if (currentAlgorithm === 'preemptive') {
                runPreemptiveDemo(timeline, log);
            } else if (currentAlgorithm === 'threading') {
                runThreadingDemo(timeline, log);
            } else if (currentAlgorithm === 'parallel') {
                runParallelDemo(timeline, log, cores);
            }
        }
        
        function runCooperativeDemo(timeline, log) {
            const tasks = ['ä»»å‹™A', 'ä»»å‹™B', 'ä»»å‹™C'];
            log.innerHTML += `<div>[0ms] å”ä½œå¼å¤šå·¥é–‹å§‹...</div>`;
            
            let currentTime = 0;
            tasks.forEach((task, index) => {
                setTimeout(() => {
                    const taskElement = document.createElement('div');
                    taskElement.className = 'task-block task-running';
                    taskElement.style.background = colors[index];
                    taskElement.textContent = task + ' (ä¸»å‹•è®“å‡º)';
                    timeline.appendChild(taskElement);
                    
                    log.innerHTML += `<div>[${currentTime}ms] ${task}é–‹å§‹åŸ·è¡Œ</div>`;
                    
                    setTimeout(() => {
                        taskElement.classList.remove('task-running');
                        taskElement.classList.add('task-completed');
                        log.innerHTML += `<div>[${currentTime + 1000}ms] ${task}ä¸»å‹•è®“å‡ºCPU</div>`;
                    }, 1000);
                    
                    currentTime += 1200;
                }, index * 1200);
            });
        }
        
        function runPreemptiveDemo(timeline, log) {
            const tasks = ['é«˜å„ªå…ˆæ¬Šä»»å‹™', 'ä¸­å„ªå…ˆæ¬Šä»»å‹™', 'ä½å„ªå…ˆæ¬Šä»»å‹™'];
            log.innerHTML += `<div>[0ms] æ¶å å¼å¤šå·¥é–‹å§‹...</div>`;
            
            // å…ˆå•Ÿå‹•ä½å„ªå…ˆæ¬Šä»»å‹™
            const lowTask = document.createElement('div');
            lowTask.className = 'task-block task-running';
            lowTask.style.background = colors[2];
            lowTask.textContent = tasks[2];
            timeline.appendChild(lowTask);
            log.innerHTML += `<div>[0ms] ${tasks[2]}é–‹å§‹åŸ·è¡Œ</div>`;
            
            // 500mså¾Œé«˜å„ªå…ˆæ¬Šä»»å‹™æ¶å 
            setTimeout(() => {
                lowTask.classList.remove('task-running');
                lowTask.classList.add('task-waiting');
                
                const highTask = document.createElement('div');
                highTask.className = 'task-block task-running';
                highTask.style.background = colors[0];
                highTask.textContent = tasks[0];
                timeline.appendChild(highTask);
                
                log.innerHTML += `<div>[500ms] ${tasks[0]}æ¶å CPU</div>`;
                log.innerHTML += `<div>[500ms] ${tasks[2]}è¢«æš«åœ</div>`;
                
                setTimeout(() => {
                    highTask.classList.remove('task-running');
                    highTask.classList.add('task-completed');
                    lowTask.classList.remove('task-waiting');
                    lowTask.classList.add('task-running');
                    
                    log.innerHTML += `<div>[1500ms] ${tasks[0]}å®Œæˆ</div>`;
                    log.innerHTML += `<div>[1500ms] ${tasks[2]}æ¢å¾©åŸ·è¡Œ</div>`;
                }, 1000);
            }, 500);
        }
        
        function runThreadingDemo(timeline, log) {
            const threads = ['ä¸»åŸ·è¡Œç·’', 'å·¥ä½œåŸ·è¡Œç·’1', 'å·¥ä½œåŸ·è¡Œç·’2'];
            log.innerHTML += `<div>[0ms] å¤šåŸ·è¡Œç·’é–‹å§‹...</div>`;
            
            threads.forEach((thread, index) => {
                setTimeout(() => {
                    const threadElement = document.createElement('div');
                    threadElement.className = 'task-block task-running';
                    threadElement.style.background = colors[index];
                    threadElement.textContent = thread;
                    timeline.appendChild(threadElement);
                    
                    log.innerHTML += `<div>[${index * 200}ms] ${thread}å•Ÿå‹•</div>`;
                    
                    setTimeout(() => {
                        threadElement.classList.remove('task-running');
                        threadElement.classList.add('task-completed');
                        log.innerHTML += `<div>[${index * 200 + 1500}ms] ${thread}å®Œæˆ</div>`;
                    }, 1500);
                }, index * 200);
            });
        }
        
        function runParallelDemo(timeline, log, cores) {
            log.innerHTML += `<div>[0ms] å¹³è¡Œè™•ç†é–‹å§‹ (${cores}æ ¸å¿ƒ)...</div>`;
            
            // å‰µå»ºCPUæ ¸å¿ƒè¦–è¦ºåŒ–
            const coreContainer = document.createElement('div');
            coreContainer.style.marginBottom = '20px';
            
            for (let i = 0; i < cores; i++) {
                const core = document.createElement('div');
                core.className = 'cpu-core';
                core.textContent = `æ ¸å¿ƒ${i + 1}`;
                core.id = `core-${i}`;
                coreContainer.appendChild(core);
            }
            timeline.appendChild(coreContainer);
            
            // åˆ†é…ä»»å‹™åˆ°ä¸åŒæ ¸å¿ƒ
            const tasks = ['è¨ˆç®—ä»»å‹™A', 'è¨ˆç®—ä»»å‹™B', 'è¨ˆç®—ä»»å‹™C', 'è¨ˆç®—ä»»å‹™D', 'è¨ˆç®—ä»»å‹™E', 'è¨ˆç®—ä»»å‹™F'];
            
            tasks.forEach((task, index) => {
                const coreIndex = index % cores;
                const core = document.getElementById(`core-${coreIndex}`);
                
                setTimeout(() => {
                    core.classList.add('active');
                    core.textContent = `åŸ·è¡Œä¸­...`;
                    
                    const taskElement = document.createElement('div');
                    taskElement.className = 'task-block task-running';
                    taskElement.style.background = colors[index % colors.length];
                    taskElement.textContent = task;
                    timeline.appendChild(taskElement);
                    
                    log.innerHTML += `<div>[${index * 100}ms] ${task}åœ¨æ ¸å¿ƒ${coreIndex + 1}é–‹å§‹</div>`;
                    
                    setTimeout(() => {
                        core.classList.remove('active');
                        core.textContent = `æ ¸å¿ƒ${coreIndex + 1}`;
                        taskElement.classList.remove('task-running');
                        taskElement.classList.add('task-completed');
                        log.innerHTML += `<div>[${index * 100 + 1000}ms] ${task}å®Œæˆ</div>`;
                    }, 1000);
                }, index * 100);
            });
        }
        
        function resetDemo() {
            document.getElementById('execution-timeline').innerHTML = '';
            document.getElementById('execution-log').innerHTML = '';
            document.getElementById('multitask-timeline').innerHTML = '';
            document.getElementById('multitask-log').innerHTML = '';
        }
        
        function formatTime(ms) {
            return ms + 'ms';
        }
        
        // åˆå§‹åŒ–
        updateAlgorithmInfo();
        updateInputFields();
        updateProcessInputVisibility();
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'98a2e504128df1d4',t:'MTc1OTcyOTk2Ny4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
